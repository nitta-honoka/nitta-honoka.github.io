{"meta":{"title":"honokaのthinking garden","subtitle":null,"description":"一处与自己闲聊的小花园","author":"honoka","url":"http://honoka.me"},"pages":[{"title":"","date":"2018-03-18T16:42:36.000Z","updated":"2018-03-18T16:42:36.000Z","comments":true,"path":"404.html","permalink":"http://honoka.me/404.html","excerpt":"","text":""},{"title":"Categories","date":"2016-05-29T05:19:38.000Z","updated":"2016-05-29T05:17:28.000Z","comments":true,"path":"categories/index.html","permalink":"http://honoka.me/categories/index.html","excerpt":"","text":"编程技术"},{"title":"Tags","date":"2016-05-29T05:19:38.000Z","updated":"2016-05-29T05:18:54.000Z","comments":true,"path":"tags/index.html","permalink":"http://honoka.me/tags/index.html","excerpt":"","text":"Git"},{"title":"about","date":"2016-04-27T15:34:43.000Z","updated":"2016-04-27T15:34:43.000Z","comments":true,"path":"about/index.html","permalink":"http://honoka.me/about/index.html","excerpt":"","text":""}],"posts":[{"title":"React 组件化在业务开发中的落地实践","slug":"React 组件化在业务开发中的落地实践","date":"2017-10-19T17:07:25.000Z","updated":"2018-03-19T17:21:32.000Z","comments":true,"path":"2017/10/20/React 组件化在业务开发中的落地实践/","link":"","permalink":"http://honoka.me/2017/10/20/React 组件化在业务开发中的落地实践/","excerpt":"当 React 融入实际业务开发，我们总是会遇见一个纠结的问题，组件如何设计：组件粒度如何控制、组件责任如何划分、组件应如何组合、组件数据如何交互？本文将探索讨论业务组件设计中的方方面面……","text":"当 React 融入实际业务开发，我们总是会遇见一个纠结的问题，组件如何设计：组件粒度如何控制、组件责任如何划分、组件应如何组合、组件数据如何交互？本文将探索讨论业务组件设计中的方方面面…… 前言React 作为 Facebook 出品的一个组件化前端框架，已经迅速深入前端开发的各个领域，同时也使组件化开发成为前端开发模式中的一个新常态。 笔者所在的团队负责开发和维护公司内部的一个 CRM 系统，该系统具有复杂且庞大的业务逻辑。为了提升开发和维护效率，其前端便采用 React 作为视图的主要框架，同时按业务切分为不同组件，使整个应用处于易装配、可追踪、可管控的状态。 接下来我们就聊聊该 CRM 系统开发中如何实践组件化开发，真正提升工作效率。 React 组件设计的重点其实关于 React 组件设计的思想，已有官方文档 [1] 珠玉在前了，那么在实际运用 React 的过程中，我们又发现了什么值得注意的重点，以及总结出什么适用的解决方案呢？下面就是实际业务开发中会遇见的一些重点和实践。 [1] 官方文档《Thinking in React》： https://reactjs.org/docs/thinking-in-react.html 组件如何划分作为一个 to B 的中后台应用，不可避免会与业务模式强绑定，所以我们的路由按照业务模块进行设计与划分，并根据路由划分顶层组件。为了保证顶层组件之间的逻辑是完全分离的，设计之初我们便需要与产品方确认每个业务模块的独立性。在这种情况下，我们可以做到能直接从业务模块定位到路由，再到顶层组件，然后一直定位到后端 Controller，都不会出现任何分叉。接下来再对顶层组件进行 UI 为准的子组件划分。 可以看出开发中我们采取了两种划分方式，一种以路由为准，划分出顶层组件，更形象的说法应该是业务组件；一种以 UI 为准，划分出展示组件，这样做的好处在于： 开发中针对每个业务模块的规则变动和需求更改是很常见的事。我们可以快速定位到相应模块进行响应。 业务组件由于与业务绑定，因为每个业务模块的隔离性，基本不会存在公用地带；而展示组件则存在很大地抽象为公有组件的空间。如此划分有助于在不断迭代的过程中，整理出那些可以抽象的组件。 有助于我们维护一个良好的数据模型，使自己的业务模块和数据模型是相同的信息架构。便于引入 Redux、Mobx 等任何数据管理框架，同时我们可以轻易地将自己的业务组件拆为不同 UI 组件，却不会带来数据模型更改的副作用。 假设我们有一个 React + Redux 的系统，划分后的应用结构应该会像下面这样： 12345678910111213141516171819202122├── api│ ├── apiA│ └── apiB├── action│ ├── actionA│ └── actionB├── reducer│ ├── reducerA│ └── reducerB├── components│ ├── ComponentA│ │ ├── index│ │ │ // 业务组件，以路由为准，和数据模型保持一致，│ │ │ // 负责展示组件的组合及状态处理、通信│ │ │ │ │ └── other child component │ │ // 展示组件，以 UI 为标准划分│ │ │ └── ComponentB│ ├── index│ └── other child component└── ... 组件状态的管理React 提供了两个途径获得组件状态，一个是自身管理的 state，另一个是父组件传递下来的 props，那么它们在实践中是如何使用的？ 如何使用 statestate 管理着组件自身的状态，可以想象成这个组件自身的血液。由于在 React 的更新机制中，state 的每一次改变都会触发组件的重新渲染（re-render），带来不必要的性能损耗。同时 state 中管理太多状态也会造成状态冗余。所以我们应尽量维持组件 stateless 化。在将状态塞进 state 之前都先思考一件事 “这个状态真的适合放进 state 吗？” 什么数据适合放进 state 呢，总结起来就是可能会改变 UI 的 flag。例如一个绑定了 UI 动效的 className，或者一个 JS 动画的判断条件 isButtonDisabled。适合放进 state 的状态通常只会有三种数据类型 Number、String 以及最常出现的 Boolean。 所以 state 常见于以下几种场景： 需要进行 UI 展示的更新时，会通过更新组件状态来进行。例如一个按钮，我们要改变其是否可点击的展现状态。 123456// good - 通过状态更新改变组件const &#123; disabled &#125; = this.state&lt;button disabeld=&#123;disabled&#125;&gt;&lt;/button&gt;// not good - 直接操作组件this.refs.btn.disabled = true 保存一个条件判断结果。例如可以通过 JSX 条件表达式判断组件是否展示，如下： 123456789const &#123; conditionA, conditionB &#125; = this.state&lt;div&gt; &#123; conditionA &amp;&amp; ComponentA &#125; &#123; conditionB ? ComponentB : ComponentC &#125;&lt;/div&gt; 组件内表单内容的存储和变化 12345678910state = &#123; username: ''&#125;render() &#123; const &#123; username &#125; = this.state return ( &lt;Input value=&#123;username&#125; onChange=&#123;v =&gt; this.setState(&#123;username: v&#125;)&#125; /&gt; ) &#125; 如何使用 propsprops 可想象成组件外部的输血管，组件会从 props 中取得自己需要的血液。对于子组件来说，父组件传递过来的 props 几乎等于一个黑盒子，子组件只能将手伸进去试着找到自己需要的状态，或者抓出一团 undefined。所以在 props 的使用中，我们需要做两件事来保证自己能更好地取到所需状态。 通过 React 提供的 PropTypes 约定信息的属性名以及类型。如同前后端协作需要先约定好接口文档，通过 PropTypes 我们也可以事先约定好该组件的 “文档”，后续开发就能够一目了然地知道这个业务组件需要什么信息，信息应该是什么样的。 定义 props 中传递信息的默认值，增强组件的容错率。当接口请求出现问题的时候，我们也能正常渲染出初始状态的页面。 1234class Com extends Component &#123; static PropTypes = &#123; xxx &#125; static defaultProps = &#123; xxx &#125;&#125; 组件数据通信组件间的数据通信会分两种情况，一种是父子通信，一种是跨组件通信，两种有其不同的处理方法。 父子组件通信React 提供了 props 以及回调函数来解决父子数据通信的问题，从父组件到子组件当然是通过 props 来传递，只要按照遵循上面所提及的 props 使用建议，已经不会出现太大问题了。不过从子组件到父组件的回调函数通信倒还有可谈的地方。 回调函数通信是什么呢，先举个简单的例子说明一下： 1234567891011121314151617class ParentCom extends Component &#123; render() &#123; // 这里通过回调函数 onChange 拿到了子组件传回的状态，并在组件方法中进行处理 return ( &lt;ChildCom onChange=&#123;childState =&gt; function(childState)&#125; /&gt; ) &#125;&#125;class ChildCom extends Component &#123; render() &#123; // 回调函数通过 props 传给子组件，然后在子组件中调用传回相应状态 return ( &lt;Com onChange=&#123;() =&gt; this.props.onChange(childState)&#125; /&gt; ) &#125;&#125; 我们需要注意的是子组件中的回调方法要做到的是通知 “我发生了什么” 而不是通知 “我要干什么”，这意味着你的组件设计得是否足够独立，特别对于抽象出来的公用组件。 例如一个 Input 组件需要向外部提供填写的文本内容，那么它应该做的是使用 onInputChange 告诉关联的外部，我的文本内容变化了，你们可以通过这个回调方法去取，至于你们要干什么，我并不关心。而不是使用 changeUsername 通知外部拿着文本内容去干某一件具体的事情。 12345// good&lt;Input onChange=&#123;v =&gt; onInputChange(v)&#125; /&gt;// not good&lt;Input onChange=&#123;v =&gt; changeUsername(v)&#125; /&gt; 跨组件通信开发大型应用的时候我们难免会遇见需要跨组件通信的情况，或者不同业务组件都要用到一套状态（如用户信息等），那么跨组件通信又有哪些方法可以选择呢？ 以 Redux 为例的 Flux 单向数据流模式，从统一管理的 Store 一路传递，通过触发更新 Store 的操作来更新 通过触发和观察自定义事件（EventEmitter）来传递数据 通常我们还是优先选择 Redux 来进行跨组件的通信和更新，以保证数据流的可观察可追踪，除非对于性能比较敏感的更新（由于 Redux 自顶向下的 re-render 更新机制），可以考虑使用事件传递数据。 React 组件设计实践的难点将 React 应用于系统开发实践中时，为了更高的可维护性及健壮性，提高多人协作的效率，真正发挥 React 的强大威力，那么就有一些坑终究是绕不过去的。 组件的复用与分治遵循着单一职责化划分好的组件，总是会被我们赋予更多复用的美好愿景，于是开始努力复用抽象自己的组件，最后发现一些令人头疼的事情。 组件怎么如此之多调用关系，修改状态牵一发而动全身，影响一大堆父组件。 组件不太适用最新业务，得加逻辑，结果组件内一长串的为不同业务设计的逻辑。业务改变之后找相应逻辑都得找很久。 其实在组件化的开发过程中，我们或许更应该注意到组件化带来的另一个重要福利分治。 例如现在有两个不同业务模型的组件 ComponentA 和 ComponentB，它们都需要在页面上展示列表。接下来，第一反应是不是得设计一个通用的列表组件，传入不同的列表数据 ListA 和 ListB 就好了。但是考虑一下以下情况，ComponentA 和 ComponentB 组件的列表有不同的业务处理规则，要怎么分别处理这些特定于某个业务模型的规则呢。 通常的组合方式为直接在业务组件处理好数据再往下传递，负责展示的列表组件就只负责展示，没有任何业务逻辑的处理。也就是说，我们要在业务组件中按照不同业务规则处理好数据，然后传入展示组件做到不同的渲染。但实际开发中业务组件会由很多个子组件组合而成，而每个子组件可能都存在自己专属的业务逻辑，全部放在业务组件中处理极易造成组件的信息冗余。 想象一下，一个业务组件中有三四个子组件的处理逻1辑，那么我们最少也需要四个方法去干这些事，如果还需要因为业务逻辑的复杂性去拆分方法，是不是已经能看到一个超长代码的组件诞生了。所以这个时候将专属于子组件的业务逻辑放在对应的子组件中是更易维护的选择。 回到刚刚的情况，两个相似的列表组件却有各自的业务规则怎么处理？我的实践是部分抽象，先抽象出来最常用的基本组件如 Table，然后再分别开发两个业务模型下的列表组件 ListA 和 ListB，它们都用到了 Table。以后其中一个业务规则有变动时，也可以灵活变动相应的列表组件，而无需拓展公用组件，也无需在父组件中寻找列表处理的逻辑在哪儿。 组件的粒度如何控制业务代码中组件抽取的粒度一直是一个比较纠结的问题，粒度太粗项目中可能会存在太多的重复代码，粒度太细会影响后续可扩展性，大部分情况下只能根据实际业务情况进行评估。但是这其中还是有一些经验可以参考： 组件树的组合不宜过深，通常控制在 3 至 5 层之间比较理想，过深的组件层级容易造成组件通讯的负担。 有几种东西一般可以被提取为可复用的组件：基础控件、公共样式，以及拥有稳定业务逻辑的组件。 直接进行 DOM 操作需要和其他非 React 架构的系统集成时，如以前和可视化库 ECharts 集成的时候，仍然只能直接进行 DOM 操作，这部分是很难做到完全组件化的，不过我们仍然可以采用更加 React 的方式去操作 DOM（现在已经有 Recharts 这样集成 ECharts 的 React 工具库）。 123456&lt;chart id='chart' ref='chart'&gt;&lt;/chart&gt;// goodconst ele = this.refs.chart// not goodconst ele = document.getElementById('chart') 避免对状态进行会产生副作用的操作开发过程中应尽量保持组件状态的纯净性，始终使用不可变数据的思想进行状态变更，避免在组件逻辑中直接对原数据使用如 pop、push、splice 等会改变原数据的方法。这样会造成数据传递中产生难以观测的改变，后续不便于追踪和管理组件更新。 123456// goodconst data = [...this.props.data]const new = data.pop()// not goodconst new = this.props.data.pop() 错误使用 state 的情况上面有谈及到 state 的正确使用模式，维护一个最小集但完备的 state，回顾以前的代码，常常会出现这么几种错误使用 state 的场景。 将计算后的数据放进 state。这里是非必要的行为，更推荐将计算过程放在 render 生命周期中，直接用计算后的数据进行渲染。如果把计算数据也交给 state 管理，就意味着需要进行许多额外的 setState 操作去保持计算数据的同步。 1234567891011121314151617// goodrender() &#123; // 直接在 render 中计算后用于渲染 const data = function(this.props.xxx) &lt;Com data=&#123;data&#125; /&gt;&#125;// not goodcomponentDidMount() &#123; // 在其它生命周期或者方法中计算后放进 state const data = function(this.props.xxx) this.setState(&#123;data&#125;)&#125;render() &#123; const &#123; data &#125; = this.state &lt;Com data=&#123;data&#125; /&gt;&#125; 同样不推荐将 React 组件直接放进 state，更应直接在 render 生命周期中进行组装。 将 props 中已经存在的数据放进 state 通常是一种画蛇添足的行为，直接使用 props 中的数据就好。会导致这个行为的大部分原因在于我们并不清楚 props 中究竟有什么，所以通过 PropTypes 进行 props 的约束说明是一件很有助于减少这类问题的事情。 后记（图片来源：Pixabay） 有这么一个有趣的问题 “怎么把大象放进冰箱”，总是会被拿来吐槽一些语焉不详的说明。不过放到应用设计中也能映射出一个道理，解决一个复杂问题的时候，我们总能找到重要的思路，但如何执行却步步维艰。对于业务开发而言，一百个人眼里就有一百种业务逻辑，很难用同一种模式套用到所有业务的设计上。 但是我们可以通过一些既有的经验举一反三，以此为基础，解决更多特殊化的难题。设计组件的过程就是对整个应用不断拆分再不断组合的过程，在其中我们成长的不仅仅是编码能力，更是全局与局部的规划能力。","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}],"tags":[{"name":"React","slug":"React","permalink":"http://honoka.me/tags/React/"}],"keywords":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}]},{"title":"闲谈 git merge 与 git rebase 的区别","slug":"闲谈 git merge 与 git rebase 的区别","date":"2016-04-28T15:21:36.000Z","updated":"2016-05-29T05:35:41.000Z","comments":true,"path":"2016/04/28/闲谈 git merge 与 git rebase 的区别/","link":"","permalink":"http://honoka.me/2016/04/28/闲谈 git merge 与 git rebase 的区别/","excerpt":"相信大部分使用 Git 的朋友都会遇见相同的疑问，并且也从网上搜索了不少资料。那么，为什么我还要写这篇文章呢？因为我想尝试从自己的角度解释这个问题，如果能给到大家灵光一闪的感悟，便善莫大焉啦。估计点进来的朋友也对 merge 和 rebase 有了一定了解，所以我也就不浪费篇幅再去详细介绍 merge 和 rebase，让我们直入主题吧。","text":"相信大部分使用 Git 的朋友都会遇见相同的疑问，并且也从网上搜索了不少资料。那么，为什么我还要写这篇文章呢？因为我想尝试从自己的角度解释这个问题，如果能给到大家灵光一闪的感悟，便善莫大焉啦。估计点进来的朋友也对 merge 和 rebase 有了一定了解，所以我也就不浪费篇幅再去详细介绍 merge 和 rebase，让我们直入主题吧。 merge 与 rebase 的区别merge(以下说明都基于 merge 的默认操作)现在假设我们有一个主分支 master 及一个开发分支 deve，仓库历史就像这样： 现在如果在 master 分支上 git merge deve：Git 会自动根据两个分支的共同祖先即 e381a81 这个 commit 和两个分支的最新提交即 8ab7cff 和 696398a 进行一个三方合并，然后将合并中修改的内容生成一个新的 commit，即下图的 78941cb。 rebaserebase 是什么情况呢？还是一个初始的仓库历史图： 如果是在 master 分支上 git rebase deve：Git 会从两个分支的共同祖先 3311ba0 开始提取 master 分支（当前所在分支）上的修改，即 85841be、a016f64 与 e53ec51，再将 master 分支指向 deve 的最新提交（目标分支）即 35b6708 处，然后将刚刚提取的修改依次应用到这个最新提交后面。操作会舍弃 master 分支上提取的 commit，同时不会像 merge 一样生成一个合并修改内容的 commit，相当于把 master 分支（当前所在分支）上的修改在 deve 分支（目标分支）上原样复制了一遍,操作完成后的版本历史就像这样： 可以看见 master 分支从 deve 分支最新提交 35b6708 开始依次提交了自己的三个 commit（由于是提取修改后重新依次提交，故 commit 的 hash 码与上面的85841be、a016f64、e53ec51 不同）。 rebase -irebase 操作加上 -i 选项可以更直观的看见被提取的 commit 信息。 仍然在 master 分支上 rebase deve 分支，不过这次要加上 -i 选项，即 git rebase -i deve，然后我们可以得到这样一个文本信息框 A 区域内的信息说明了这次 rebase 操作提取了哪些 commit 记录（f9a7673 与 edb2ba2），会连接到目标分支的哪个 commit （9c86a5c）后面。可以根据 B 区域中的命令说明修改 pick 为其他命令，对该次提取出来的 commit 做额外的操作 B 区域内说明了本次 rebase 操作可以选用的命令 通过 :wq 保存退出后，就会按照刚刚在 A 区域内设定的命令处理 commit 并 rebase。 冲突处理策略的不同 merge 遇见冲突后会直接停止，等待手动解决冲突并重新提交 commit 后，才能再次 merge rebase 遇见冲突后会暂停当前操作，开发者可以选择手动解决冲突，然后 git rebase --continue 继续，或者 --skip 跳过（注意此操作中当前分支的修改会直接覆盖目标分支的冲突部分），亦或者 --abort 直接停止该次 rebase 操作 总结：选择 merge 还是 rebase？ merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容 merge 的提交历史忠实地记录了实际发生过什么，关注点在真实的提交历史上面 rebase 并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面 rebase 的提交历史反映了项目过程中发生了什么，关注点在开发过程上面 merge 与 rebase 都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定。但是在大部分情况下，个人建议使用 rebase + merge –ff-only 的组合，这样可以使整个版本历史更加简洁，在大型项目中的效果可以参考 GO 的版本历史。 merge 和 rebase 还有很多强大的选项，可以使用 git help &lt;command&gt; 查看 最后：一些注意点 使用 merge 时应考虑采用默认操作，还是 --no-ff 或 --ff-only 的方式 rebase 操作会丢弃当前分支已提交的 commit，故不要在已经 push 到远程，和其他人正在协作开发的分支上执行 rebase 操作 与远程仓库同步时，使用 pull 命令默认进行了 git fetch + git merge 两个操作，可以通过加上 --rebase 命令将 fetch 后的 merge 操作改为 rebase 操作，或者仅仅 ‘git fetch remoteName’,然后才思考采取哪种整合策略 git merge(or rebase) origin/master 开发与 commit 时注意自己此时在哪个分支上 当有修改未 commit 时，不能进行 rebase 操作，此时可以考虑先用 git stash 命令暂存 参考 ProGit 2nd Edition Stackoverflow:Is there a difference between git rebase and git merge –ff-only Git分支管理策略","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://honoka.me/categories/编程技术/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://honoka.me/tags/Git/"}],"keywords":[{"name":"编程技术","slug":"编程技术","permalink":"http://honoka.me/categories/编程技术/"}]},{"title":"CSS 布局实例系列（四）如何实现容器中每一行的子容器数量随着浏览器宽度的变化而变化？","slug":"CSS布局实例系列（四）如何实现容器中每一行的子容器数量随着浏览器宽度的变化而变化？","date":"2016-01-27T17:08:46.000Z","updated":"2018-04-16T17:23:40.000Z","comments":true,"path":"2016/01/28/CSS布局实例系列（四）如何实现容器中每一行的子容器数量随着浏览器宽度的变化而变化？/","link":"","permalink":"http://honoka.me/2016/01/28/CSS布局实例系列（四）如何实现容器中每一行的子容器数量随着浏览器宽度的变化而变化？/","excerpt":"Hello，小朋友们，还记得我是谁吗？对了，我就是~超威~好啦，言归正传，今天的布局实例是： 实现一个浮动布局，红色容器中每一行的蓝色容器数量随着浏览器宽度的变化而变化 肯定有人心里犯嘀咕了，哈~这么简单，不就是全部左浮动嘛，这也好意思拿出来讲？别急啊，其实里面的坑还是挺多的，且待我一个个填上。","text":"Hello，小朋友们，还记得我是谁吗？对了，我就是~超威~好啦，言归正传，今天的布局实例是： 实现一个浮动布局，红色容器中每一行的蓝色容器数量随着浏览器宽度的变化而变化 肯定有人心里犯嘀咕了，哈~这么简单，不就是全部左浮动嘛，这也好意思拿出来讲？别急啊，其实里面的坑还是挺多的，且待我一个个填上。 要实现什么样的效果呢，如图： 通过左浮动实现 要实现这样一个布局，我们首先需要如下的 HTML： 1234567891011&lt;div id=\"float-container\"&gt; &lt;div class=\"float-element\"&gt;&lt;/div&gt; &lt;div class=\"float-element\"&gt;&lt;/div&gt; &lt;div class=\"float-element\"&gt;&lt;/div&gt; &lt;div class=\"float-element\"&gt;&lt;/div&gt; &lt;div class=\"float-element\"&gt;&lt;/div&gt; &lt;div class=\"float-element\"&gt;&lt;/div&gt; &lt;div class=\"float-element\"&gt;&lt;/div&gt; &lt;div class=\"float-element\"&gt;&lt;/div&gt; &lt;div class=\"float-element\"&gt;&lt;/div&gt;&lt;/div&gt; 然后开始写 CSS 吧： 12345678910#float-container &#123; background-color: red;&#125;.float-element &#123; float: left; width: 50px; height: 30px; background-color: blue; margin: 10px;&#125; 使每个小容器向左浮动，再设定一个边距，一个根据浏览器宽度自适应变化位置的浮动布局就搞定收工了？当然不会，效果会像这样： 说好的红色背景大容器呢，怎么躲起来啦？检查一番，原来是忘了给大容器 div 设定宽高度了，那就设定一下宽高度。既然要求了大容器自适应，那么我们就分别设定为 100% 吧： 123456789101112#float-container &#123; background-color: red; height: 100%; width: 100%;&#125;.float-element &#123; float: left; width: 50px; height: 30px; background-color: blue; margin: 10px;&#125; 好啦，刷新一下。大容器咋还是没出来？ 现在让我们分析一下吧： 为何看不见大容器？ 因为 div 如果没有包裹元素的话，百分比宽高度是不会产生效果的。 那么为什么大容器明明包裹着九个 div，百分比宽高度却没有产生效果呢？ 因为小容器都设定为左浮动，已经脱离文档流，大容器并没有包围小容器，表现出高度为0（高度塌陷）。 接下来我们想要大容器自适应，又不想使小容器失去浮动的特性，能够随着宽度变化自动调整每一行的个数，应该怎么办？ \b我们需要闭合浮动元素，使其包含框表现出正常的高度。是时候请出我们的 BFC 大神啦，对，我已经连续三篇实例博文提到 BFC 原理了，因为这个原理就是这么有用啊（\b该处原理的详细介绍请参考一丝大神的《那些年我们一起清除过的浮动》）。现在我们在大容器加上 overflow: hidden; 就可以自动清理其包含的任何浮动元素，接下来看看最终的 DEMO，试着调整一下宽度，是不是已经实现了想要的效果？ See the Pen float-container by xal821792703 (@honoka) on CodePen. 通过 inline-block 实现只能通过左浮动完成这个实例？并不是，我们还有 inline-block。inline-block 可以像行内元素一样水平地依次排列，但框的内容仍然符合块级框的行为。通过这一特性，我们可以利用 inline-block 像浮动一样创建很多网格铺满容器，并且不需要清除浮动。当然整个布局过程也比左浮动简便了一些，\b如下面的 DEMO： See the Pen inline-block-container by xal821792703 (@honoka) on CodePen. 其实还有更加简便的方案，使用 flex，这里提供一个思路给大家看看如何实现（笑） 最后感谢大家的阅读，欢迎前往我的 repo 查看源代码整理，有任何问题也请尽情向我吐槽。","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://honoka.me/tags/CSS/"}],"keywords":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}]},{"title":"CSS 布局实例系列（三）也聊聊双飞翼，如何实现一个左右宽度固定，中间自适应的三列布局","slug":"CSS布局实例系列（三）也聊聊双飞翼，如何实现一个左右宽度固定，中间自适应的三列布局","date":"2016-01-26T16:50:15.000Z","updated":"2018-04-16T17:24:53.000Z","comments":true,"path":"2016/01/27/CSS布局实例系列（三）也聊聊双飞翼，如何实现一个左右宽度固定，中间自适应的三列布局/","link":"","permalink":"http://honoka.me/2016/01/27/CSS布局实例系列（三）也聊聊双飞翼，如何实现一个左右宽度固定，中间自适应的三列布局/","excerpt":"今天聊聊一个经典的布局实例： 实现一个三列布局，其中左侧和右侧的部分宽度固定，中间部分宽度随浏览器宽度的变化而自适应变化 可能很多朋友\b已经笑了\b，这玩意儿通过双飞翼布局就能轻松实现。不过，还请容我在双飞翼之外，循序渐进地介绍一下我们\b可以如何实现一个三列布局。","text":"今天聊聊一个经典的布局实例： 实现一个三列布局，其中左侧和右侧的部分宽度固定，中间部分宽度随浏览器宽度的变化而自适应变化 可能很多朋友\b已经笑了\b，这玩意儿通过双飞翼布局就能轻松实现。不过，还请容我在双飞翼之外，循序渐进地介绍一下我们\b可以如何实现一个三列布局。 首先，使用浮动布局来实现See the Pen float-three-column by xal821792703 (@honoka) on CodePen. 左侧元素与右侧元素优先渲染，分别向左和向右浮动 中间元素在文档流的最后渲染，并将 width 设为 100%，则会自动插入到左右两列元素的中间，随后设置 margin 左右边距分别为左右两列的宽度，\b将中间元素调整到正确的位置。 这是一种比较便利的实现方式，无需额外的元素辅助定位，同时兼容性也比较优秀。但有一个缺点就是该布局方式只能实现左右两列宽度固定，中间自适应这一种三列布局，灵活性不强。 其实，也可以试试利用 BFCSee the Pen bfc-three-columns by xal821792703 (@honoka) on CodePen. 之前的文章《CSS 布局实例系列（\b二）如何通过 CSS 实现一个左边固定宽度、右边自适应的两列布局》已经谈到了利用 BFC 原理实现多列布局的方法。BFC 元素不会与浮动元素叠加，自然也可以完成这个实例。 同样的左右两列元素优先渲染，并分别左右浮动。 接下来将中间元素\b设置 overflow: hidden; \b成为 BFC 元素块，不与两侧浮动元素叠加，则自然能够插入自己的位置啦。 接下来就尝试一下大名鼎鼎的双飞翼布局See the Pen grid-three-columns by xal821792703 (@honoka) on CodePen. 双飞翼是由淘宝玉伯等前端大牛提出的一种多列布局方法，主要利用了浮动、负边距、相对定位三个布局属性，使三列布局就像小鸟一样，拥有中间的身体和两侧的翅膀。 接下来就简单介绍一下双飞翼的实现\b过程： 假设我们现在需要一个如实例说明一样的三列布局，写出如下 div 结构： 12345&lt;div class=\"grid\"&gt; &lt;div id=\"div-middle-02\"&gt;&lt;span&gt;div-middle&lt;/span&gt;&lt;/div&gt; &lt;div id=\"div-left-02\"&gt;&lt;span&gt;div-left&lt;/span&gt;&lt;/div&gt; &lt;div id=\"div-right-02\"&gt;&lt;span&gt;div-right&lt;/span&gt;&lt;/div&gt;&lt;/div&gt; 首先我们将中间元素放在文档流最前面优先渲染，然后使其向左浮动，并设置 width 为 100%： 123456#div-middle-02 &#123; float: left; background-color: #fff9ca; width: 100%; height: 50px;&#125; 中间元素直接占满全列，形成小鸟的\b身体。 接下来我们开始为\b小鸟加上双翼，将左右两列元素均设为左浮动，然后通过调整负边距将其定位在各自的位置上： 1234567891011121314151617181920#div-middle-02 &#123; float: left; background-color: #fff9ca; width: 100%; height: 50px;&#125;#div-left-02 &#123; float: left; background-color: red; width: 150px; margin-left: -100%; height: 50px;&#125;#div-right-02 &#123; float: left; background-color: yellow; width: 200px; margin-left: -200px; height: 50px;&#125; 看起来，双翼安装成功啦。 这样三列布局就大功告成了？No，no，no，仔细看看上面的效果图，可以发现 div-middle 的字块消失了。这是因为通过负边距调整浮动元素位置时，会产生层叠的效果，上面的布局其实只是左右两列元素分别定位在自己的位置上并覆盖中间元素的那部分而已，中间元素的定位并未成功。中间元素要怎样定位在自己的位置上呢？小鸟的身体不是还缺少骨架嘛，那么我们在小鸟体内加上骨架吧： 123&lt;div id=\"div-middle-02\"&gt; &lt;div id=\"middle-wrap-02\"&gt;&lt;span&gt;div-middle&lt;/span&gt;&lt;/div&gt;&lt;/div&gt; 在中间元素中再增加\b一层包裹，通过这层骨架我们就可以方便地控制小鸟身体的位置啦，方法就是调整骨架的左右边距，使其分别等于左右两列的宽度： 123456789101112131415161718192021222324252627#div-middle-02 &#123; float: left; background-color: #fff9ca; width: 100%; height: 50px;&#125;#middle-wrap-02 &#123; margin: 0 200px 0 150px;&#125;#div-left-02 &#123; float: left; background-color: red; width: 150px; margin-left: -100%; height: 50px;&#125;#div-right-02 &#123; float: left; background-color: yellow; width: 200px; margin-left: -200px; height: 50px;&#125; 好啦，一个左右定宽，中间自适应的三列布局以双飞翼的方式成功完成。 总结整个过程，就是先放好身体，再加上翅膀，然后让身体包裹一层骨架，通过骨架将身体定位到正确的位置。这就是双飞翼布局的完全体吗？当然不是，接下来我们要请出大杀器相对布局啦，就像小鸟可以通过各种不同的姿势飞翔一般，通过 position: relative; 双飞翼可以实现任意的三列或双列布局。本实例\b加上相对定位，便成为了这样的完全体： 1234567891011121314151617181920212223242526272829#div-middle-02 &#123; float: left; background-color: #fff9ca; width: 100%; height: 50px;&#125;#middle-wrap-02 &#123; margin: 0 200px 0 150px;&#125;#div-left-02 &#123; float: left; position: relative; background-color: red; width: 150px; margin-left: -100%; height: 50px;&#125;#div-right-02 &#123; float: left; position: relative; background-color: yellow; width: 200px; margin-left: -200px; height: 50px;&#125; 双飞翼能够兼容到 IE6，其可以实现的各种布局在此便不作展开了，有兴趣可以参考玉伯分享的 DEMO 跟上潮流，\b试试 flexSee the Pen flex-three-columns by xal821792703 (@honoka) on CodePen. 看完了强大的双飞翼布局，是不是已经心急火燎，想亲手试试啦。别\b急，客官，再听我唠唠 CSS3 的新布局 flex 呗。先让我说明一下上面的 DEMO 中是怎样实现本次实例的： 设计一个弹性容器包裹需定位的三个元素，然后将该弹性容器的排列属性设为水平排列（flex-flow: row） 现在三个元素已经是三列布局了，再将三列元素分别设定一下宽度就行了，左右元素设定为定宽，自适应的中间元素设定为 100%。 12345678910111213141516171819202122.flex &#123; display: flex; flex-flow: row;&#125;#div-left-03 &#123; background-color: red; width: 150px; height: 50px;&#125;#div-middle-03 &#123; background-color: #fff9ca; width: 100%; height: 50px;&#125;#div-right-03 &#123; background-color: yellow; width: 200px; height: 50px;&#125; 搞定收工！大哥你瞪着我是怎么回事儿？~ 什么？效果不对？我的代码怎么可能不对？！哎呦，别打我，我马上检查[捂脸]好吧，宽度不对，左右两侧的宽度均不符合设定的定值。什么情况呢？原来在 flex 布局中不能将被定位的元素宽度或高度设定为 100%，这样会影响其他定值大小的元素。那么该如何设置中间元素的宽度呢，flex: 1; 即可，可以试一下 DEMO 中去掉注释与不去掉的区别。 最后简单介绍一下 flex：flex 是 CSS3 的一种弹性容器布局，通过 flex，几行简单的 CSS 语句便可以实现各种布局（对！我就是 flex NC粉~被拍飞~）。那么 flex 有什么缺点呢？兼容性！ 所以在使用 flex 的时候还请注意是否兼容当前浏览器，是否需要 -webkit- 标签。flex 的具体语法和各类实例因为篇(lan)幅(de)过(xie)多的\b原因，也不做过多介绍了，可以参考阮一峰老师的博文： Flex 布局教程：语法篇 Flex 布局教程：实例篇 最后感谢大家的阅读，欢迎前往我的 repo 查看源代码整理，有任何问题也请尽情向我吐槽。","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://honoka.me/tags/CSS/"}],"keywords":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}]},{"title":"CSS 布局实例系列（二）如何通过 CSS 实现一个左边固定宽度，右边自适应的两列布局","slug":"CSS布局实例系列（二）如何通过CSS实现一个左边固定宽度，右边自适应的两列布局","date":"2016-01-23T16:41:42.000Z","updated":"2018-04-16T17:26:25.000Z","comments":true,"path":"2016/01/24/CSS布局实例系列（二）如何通过CSS实现一个左边固定宽度，右边自适应的两列布局/","link":"","permalink":"http://honoka.me/2016/01/24/CSS布局实例系列（二）如何通过CSS实现一个左边固定宽度，右边自适应的两列布局/","excerpt":"最近在百度 IFE 训练营中看见的一道题目： 用两种不同的方法来实现一个两列布局，其中左侧部分宽度固定、右侧部分宽度随浏览器宽度的变化而自适应变化 聊聊相应的实现思路","text":"最近在百度 IFE 训练营中看见的一道题目： 用两种不同的方法来实现一个两列布局，其中左侧部分宽度固定、右侧部分宽度随浏览器宽度的变化而自适应变化 聊聊相应的实现思路 通过绝对定位实现See the Pen absolute-two-column by xal821792703 (@honoka) on CodePen. 注意点如下： 需要套一个相对定位的父元素 div-a 绝对定位，并将位置调整为浏览器左上角 div-b margin-left 属性值为 div-a 的宽度（因为 div-a 绝对定位已经脱离文档流，故不设定为 div-a 宽度的话，会相互覆盖） div-c 绝对定位并将位置调整为正下方 需要自适应的 div 均设定宽度为100% 通过浮动实现See the Pen float-two-column by xal821792703 (@honoka) on CodePen. 注意点如下： div-a 设定为左浮动 div-b 与上面一样需要将 margin-left 属性值设为 div-a 的宽度，原因同上，浮动也会脱离文档流 div-c 最好清除浮动，避免浮动的影响 通过 BFC 规则实现See the Pen bfc-two-column by xal821792703 (@honoka) on CodePen. 此处便不花大量篇幅介绍 BFC 了，可以参见下面两篇博文： 深入理解BFC和Margin Collapse CSS之BFC详解 简而言之，BFC 可以帮助我们解决布局中左边元素脱离文档流后，右边元素的左外边距会触碰到包含块容器的左外边框的问题，就像下图： 现在我们仅需注意将 div-b 设定为 BFC 元素即可。 以上便是个人总结出的三种两列布局方法，源\b代码已同步至个人 repo，欢迎参考交流（笑）","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://honoka.me/tags/CSS/"}],"keywords":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}]},{"title":"CSS 布局实例系列（一）总结 CSS 居中的多种方法","slug":"CSS布局实例系列（一）总结CSS居中的多种方法","date":"2016-01-20T16:30:33.000Z","updated":"2018-04-16T17:27:11.000Z","comments":true,"path":"2016/01/21/CSS布局实例系列（一）总结CSS居中的多种方法/","link":"","permalink":"http://honoka.me/2016/01/21/CSS布局实例系列（一）总结CSS居中的多种方法/","excerpt":"使用 CSS 让页面元素居中可能是我们页面开发中最常见的拦路虎啦，接下来总结一下常见的几种居中方法吧。","text":"使用 CSS 让页面元素居中可能是我们页面开发中最常见的拦路虎啦，接下来总结一下常见的几种居中方法吧。 水平居中 text-align 与 inline-block 的配合 See the Pen mVpVEr by xal821792703 (@honoka) on CodePen. HTML 中在想要居中的元素外面套了一个父元素，然后在 CSS 中将父元素的 text-align 属性设为 center，接下来将子元素的 display 属性设为 inline-block 就可以水平居中了。 通过 margin 实现 See the Pen rxpxmR by xal821792703 (@honoka) on CodePen. 通过 margin 实现连父元素都不用套了，直接 margin: 0 auto; 搞定，对，就是这么简单快捷，恐怕是居中最常用的方法了吧。 好啦，现在老板表示只是水平居中不行，还得垂直居中，该怎么办呢？ 垂直居中 还是先用 margin 来实现绝对定位元素的水平垂直居中吧 See the Pen NxXxBz by xal821792703 (@honoka) on CodePen. 注意代码中的几个关键点： 子元素 div 绝对定位 父元素需要被定位 子元素 top、bottom、left、right 四个位置值均为 0 子元素 margin: auto;\b 接下来使用来自 CSS3 的新杀器 flex See the Pen xZpZMw by xal821792703 (@honoka) on CodePen. 使用 flex 容器布局实现水平垂直居中的关键点在于： 父元素 display 属性设为 flex 垂直布局的属性是 align-items，设为 center 时便垂直居中 水平布局的属性是 justify-content，设为 center 时水平居中 子元素弹性居中，增加子元素也不会有影响 另外\b请注意兼容性问题，见下图： 总结其实利用 CSS 实现居中还有许多方法我没有写在博文中，\b如何选择居中的技术方案，最后还是得取决于当前业务场景下的浏览器支持程度和适合度。顺带一提个人最喜欢使用的是 flex 方案。 源\b代码已同步至个人 repo，欢迎参考交流（笑）","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://honoka.me/tags/CSS/"}],"keywords":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}]},{"title":"JavaScript 中 onload 事件绑定多个方法的优化建议","slug":"JavaScript中onload事件绑定多个方法的优化建议","date":"2015-10-16T16:02:30.000Z","updated":"2018-04-16T16:10:59.000Z","comments":true,"path":"2015/10/17/JavaScript中onload事件绑定多个方法的优化建议/","link":"","permalink":"http://honoka.me/2015/10/17/JavaScript中onload事件绑定多个方法的优化建议/","excerpt":"onload 事件中多个方法处理的优化方案","text":"onload 事件中多个方法处理的优化方案 页面加载完毕时会触发 onload 事件。基于内容（HTML）要与行为（JavaScript）分离的编码思想，我们需要将一些对页面的初始化操作写在方法内，并通过 window.onload = functionName 调用这些方法. 需要调用多个方法时，若使用 12window.onload = functionA;window.onload = functionB; 它们之中只有最后一个方法会被实际调用。那么应如何实现调用多个方法呢？ 直接在 HTML 中编写: 1&lt;body onload=\"functionA();functionB()\"&gt; 由于事件包含在 HTML 内，不符合上述『内容与行为分离』的思想，故不推荐使用这个方法。 创建一个匿名函数容纳需要调用的方法，然后将该匿名函数绑定到 onload 事件上： 1234window.onload = function () &#123; functionA(); functionB();&#125; 在需要调用的函数不是太多的时候，这是最简单的解决方案了。 当需要调用的方法较多时，我们可以进一步优化，编写一个专门用于绑定 onload 事件的方法： 123456789101112131415161718function addLoadEvent(func) &#123; //把现有的 window.onload 事件处理函数的值存入变量 var oldOnload = window.onload; if (typeof window.onload != \"function\") &#123; //如果这个处理函数还没有绑定任何函数，就像平时那样添加新函数 window.onload = func; &#125; else &#123; //如果处理函数已经绑定了一些函数，就把新函数添加到末尾 window.onload = function() &#123; oldOnload(); func(); &#125; &#125; &#125; //接下来，我们只需要调用这个方法添加自己需要的函数就行了 addLoadEvent(functionA); addLoadEvent(functionB); 现在不管代码变得多么复杂，当我们需要在页面加载完毕时调用多少函数，只需要多写一条语句既可解决。","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://honoka.me/tags/JavaScript/"}],"keywords":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}]},{"title":"Github 恶搞教程（一起『玩坏』自己的 Github 吧）","slug":"Github恶搞教程（一起『玩坏』自己的Github）","date":"2015-10-09T16:14:13.000Z","updated":"2018-04-16T17:32:08.000Z","comments":true,"path":"2015/10/10/Github恶搞教程（一起『玩坏』自己的Github）/","link":"","permalink":"http://honoka.me/2015/10/10/Github恶搞教程（一起『玩坏』自己的Github）/","excerpt":"最近在伯乐在线读到一篇趣文，《如何在 Github『正确』做贡献》，里面各种能人恶搞 Github 的『Public contributions』，下面截取几个小伙伴的战绩： 顺藤摸瓜，发现原来有人已经做出『玩坏』Github 的工具啦，名叫 gitfiti。主要对应预先定义的模板，进行相应日期的 commit 操作，push 至 Github 后在贡献栏中生成相应像素点，并且利用 Github 贡献数不同颜色深度不同的机制，就可以在自己的贡献栏里面看见像素画了。怎么样，是不是心动啦，那么下面就让我们开始『玩坏』之旅吧。","text":"最近在伯乐在线读到一篇趣文，《如何在 Github『正确』做贡献》，里面各种能人恶搞 Github 的『Public contributions』，下面截取几个小伙伴的战绩： 顺藤摸瓜，发现原来有人已经做出『玩坏』Github 的工具啦，名叫 gitfiti。主要对应预先定义的模板，进行相应日期的 commit 操作，push 至 Github 后在贡献栏中生成相应像素点，并且利用 Github 贡献数不同颜色深度不同的机制，就可以在自己的贡献栏里面看见像素画了。怎么样，是不是心动啦，那么下面就让我们开始『玩坏』之旅吧。 首先得将插件下载到本地，有 Git 经验的朋友可以直接 clone 这个 repo 1git clone git@github.com:gelstudios/gitfiti.git 或者点击 Github 页面的下载链接将整个项目下载到本地 下载的同时在自己的 Github 中创建一个新的 repo，名字自取，不要创建 license 和 readme（防止后面 push 的时候产生冲突）。 下载到本地后在命令行中运行 gitfiti.py，显出欢迎界面，此时第一条交互信息不用填写什么内容，直接回车即可。 接着输入自己的 Github 用户名和刚刚新建的 repo 名。 然后选择从哪里开始绘图，输入一个数字，代表从贡献栏的第几周开始（从左开始数），如果此处不输入直接回车则默认从最左边开始。 接下来会提醒你，对比你已有的贡献后，一天中最大的贡献数是多少，然后让你选择本次绘图生成的像素点的最大贡献数（Github 的像素块颜色机制为贡献相对越大的那天颜色越深）。建议此处直接使用自己的最大贡献数，否则自己之前的贡献就全部变成浅绿了。 此处输入 gitfiti 就表示使用自己的最大贡献数。 然后就可以选择绘图模板了，此处可以使用自定义模板或者开发者已经设定好的模板。 要使用自定义模板就在上面那一行中输入模板的文件路径，自定义模板的方法可以参见该项目的说明页。如果使用开发者设定的模板，上面一行就直接回车，然后下面选择模板，输入心仪的模板名字（模板名对应图案效果同样参见项目说明页）。 一切搞定后，项目会自动生成一个 shell 脚本 gitfiti.sh，接下来运行这个脚本便可以自动commit 并 push 至你新建的那个 repo，等待一段时间，你便能在自己的贡献栏看见有趣的像素画啦。 注意：此处可能会遇见两个问题 生成的 shell 脚本没有运行权限。直接运行一下 chmod 777 gitfiti.sh 即可。 push 不成功，一般是因为新 repo 里面已经有文件，push 产生冲突。可以打开 gitfiti.sh，修改最后一行 12git push -u origin master //改为下面这行git push -f -u origin master //如果有冲突强制合并 晒晒自己的战果（这次『恶搞』生成了 4W+ 的贡献o(╯□╰)o），也欢迎来我的 Github 看看。 最后如果想取消这个效果，直接删除创建的 repo，贡献栏和贡献数就会回归正常。 祝大家玩得愉快！","categories":[{"name":"趣味生活","slug":"趣味生活","permalink":"http://honoka.me/categories/趣味生活/"}],"tags":[{"name":"Git, JustForFun","slug":"Git-JustForFun","permalink":"http://honoka.me/tags/Git-JustForFun/"}],"keywords":[{"name":"趣味生活","slug":"趣味生活","permalink":"http://honoka.me/categories/趣味生活/"}]},{"title":"Java 重写 equals 与 hashCode 的注意事项","slug":"Java重写equals与hashCode的注意事项","date":"2015-09-21T15:45:10.000Z","updated":"2018-04-16T16:00:23.000Z","comments":true,"path":"2015/09/21/Java重写equals与hashCode的注意事项/","link":"","permalink":"http://honoka.me/2015/09/21/Java重写equals与hashCode的注意事项/","excerpt":"为什么重写 equals 的时候必须重写 hashCode？我们需要注意什么？","text":"为什么重写 equals 的时候必须重写 hashCode？我们需要注意什么？ 为什么重写 equals 的时候必须重写 hashCode大家可能从很多教程中了解到： SUN官方的文档中规定： 如果重定义 equals 方法，就必须重定义 hashCode 方法,以便用户可以将对象插入到散列(哈希)表中 那么 SUN 公司是出于什么考虑做了这个规定呢？ 在集合框架中的 HashSet，HashTable 和 HashMap 都使用哈希表的形式存储数据，而 hashCode 计算出来的哈希码便是它们的身份证。哈希码的存在便可以： 快速定位对象，提高哈希表集合的性能。只有当哈希表中对象的索引即 hashCode 和对象的属性即 equals 同时相等时，才能够判断两个对象相等。 从上面可以看出，哈希码主要是为哈希表服务的，其实如果不需要使用哈希表，也可以不重写 hashCode。但是 SUN 公司应该是出于对程序扩展性的考虑（万一以后需要将对象放入哈希表集合中），才会规定重写 equals 的同时需要重写 hashCode，以避免后续开发不必要的麻烦。 重写 equals 的注意事项Java 语言规范要求 equals 需要具有如下的特性： 自反性：对于任何非空引用 x，x.equals() 应该返回 true。 对称性：对于任何引用 x 和 y，当且仅当 y.equals(x) 返回 true，x.equals(y) 也应该返回 true。 传递性：对于任何引用 x、y 和 z，如果 x.equals(y) 返回 true，y.equals(z) 也应返回同样的结果。 一致性：如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果。对于任意非空引用 x，x.equals(null) 应该返回 false。 如何重写 equals在对象比较时，我们应该如何编写出一个符合特性的 equals 方法呢，《Core Java》中提出了如下建议： 显式参数命名为 otherObject，稍后将它转换成另一个叫做 other 的变量。 检测 this 与 otherObject 是否引用同一个对象： 1if (this == otherObject) return true; 计算这个等式可以避免一个个比较类中的域，实现优化。 检测 otherObject 是否为 null，如果为 null，返回 false。进行非空校验是十分重要的。 比较 this 与 otherObject 是否属于同一个类。 如果每个子类都重写了 equals，使用 getClass 检验： 12if (getClass() != otherObject.getClass()) return false; 如果所有子类都使用同一个 equals，就用 instanceof 检验： 12if (!(otherObject instanceof ClassName)) return false; 将 otherObject 转换为相应的类型变量。 1ClassName other = (ClassName) otherObject; 现在可以对所有需要比较的域进行比较了。 基本类型使用 == 比较 对象使用 equals 比较 数组类型的域可以使用静态方法 Arrays.equals 检测相应数组元素是否相等 如果所有域匹配，则返回 true 注意：子类重写父类 equals 方法时，必须完全覆盖父类方法，不能因为类型错误或者其他原因定义了一个完全无关的方法。可以使用 @Override 注解对覆盖父类的方法进行标记，这样编译器便会检测到覆盖过程中的错误。 重写 hashCode 的注意事项散列码（hash code）是由对象导出的一个整型值。散列码没有规律，在不同的对象中通过不同的算法生成，Java 中生成 hashCode 的策略为（以下说明均摘自 Java API 8）： String 类的 hashCode 根据其字符串内容，使用算法计算后返回哈希码。 Returns a hash code for this string. The hash code for a String object is computed as s[0]31^(n-1) + s[1]31^(n-2) + … + s[n-1] Integer 类返回的哈希码为其包含的整数数值。 Returns: a hash code value for this object, equal to the primitive int value represented by this Integer object. Object 类的 hashCode 返回对象的内存地址经过处理后的数值。 Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by HashMap. 在自己的类中想要重写 hashCode 的话一般怎么做呢？建议合理地组合实例域的散列码，让各个不同对象产生的散列码更加均匀。例如我们现在有一个 Cat 对象，它有 name、size 和 color 三个不同域，那么可以重写 hashCode 方法如下： 12345678910class Cat &#123; ...... public int hashCode() &#123; // hashCode 是可以返回负值的 return 6 * name.hashCode() + 8 * new Double(size).hashCode() + 10 * color.hashCode(); &#125; ......&#125; 当然还有更好的做法，我们可以直接调用静态方法 Objects.hash 并提供多个参数。这个方法会对各个参数调用 Object.hashCode，并组合返回的散列码。故以上的方法可以缩写为： 123public int hashCode() &#123; return Objects.hash(name, size, color);&#125; 注意： equals 与 hashCode 的定义必须一致，两个对象 equals 为 true，就必须有相同的 hashCode。例如：如果定义的 equals 比较的是小猫的 name，那么 hashCode 就需要散列该 name，而不是小猫的 color 或 size。 参考 《Core Java》卷一 【哈希表数据结构】【深入理解hashcode &amp; equals】","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://honoka.me/categories/编程技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://honoka.me/tags/Java/"}],"keywords":[{"name":"编程技术","slug":"编程技术","permalink":"http://honoka.me/categories/编程技术/"}]},{"title":"【译】Java语言速览：StackOverflow","slug":"【译】Java语言速览 by StackOverflow","date":"2015-09-17T15:37:53.000Z","updated":"2018-04-16T15:43:47.000Z","comments":true,"path":"2015/09/17/【译】Java语言速览 by StackOverflow/","link":"","permalink":"http://honoka.me/2015/09/17/【译】Java语言速览 by StackOverflow/","excerpt":"StackOverflow 是活跃度非常高的编程问答平台，上面对于编程语言的速览可作为良好的 Java 入门和查疑解惑的材料。","text":"StackOverflow 是活跃度非常高的编程问答平台，上面对于编程语言的速览可作为良好的 Java 入门和查疑解惑的材料。 Java (请不要与 JavaScript 搞混) 是一种设计为与 Java 虚拟机 （JVM） 一起使用的多用途编程语言。一般称呼安装了相关工具使其可以开发并运行 Java 程序的电脑系统为 “Java 运行平台”。使用这个标签可以查找有关 Java 编程语言或者 Java 平台工具的问题。 Java 是一种高性能、跨平台、面向对象的编程语言和运行环境。Java 大部分语法起源于 C 和 C++，但是其对象模型简于 C++，并且减少了低级功能。Java 应用均被编译为字节码（被称为 class 文件），使其可以被 JVM（Java 虚拟机）执行，并独立于不同的电脑体系。JVM 通过一个垃圾收集器（查看 garbage-collection）帮助管理内存，当对象不再使用时可以将其从内存中移除。Java 的系统类型是静态、强类型、安全、声明类型和显式的。Java 支持反射、接口等与 C 和 C++ 相似的功能，例如 JNI（The Java Native Interface）。 Java 被设计为尽可能减少与电脑系统的依赖关系，可以允许应用开发者 “一处编写，处处运行”（WORA）：在一个平台上执行的代码不需重新编译就能在其他机器上运行。Java 最初由 James Gosling 在 Sun Mircosystems 公司（2009年4月20日已被 Oracle 并购）设计，最初是于 1995 年作为 Sun Microsystems公司 Java 运行平台的核心元件发行。 安装工具用于开发和运行 Java 的电脑系统被 Sun（现为 Oracle）命名为 Java 运行平台。各种具有平台特性的工具可以帮助开发者更有效率地使用 Java 程序语言开发。 平台包含两个基本的软件包： Java 运行环境（JRE）：用于运行 Java 应用和程序； Java 开发工具包（JDK）：用于开发 Java 应用和程序。JDK 总是伴随着一个 JRE。 在本节中，我们将进一步探讨这两个软件包作为 Java 运行平台的组成部分，其产生的作用。 背景作为参考的大部分 Java 实现方式都是开源的（the OpenJDK），由包括 Oracle，Apple，SAP 与 IBM 在内的大型企业提供支持。 极少的电脑可以直接运行 Java 程序。因此，Java 环境通常要求安装合适的软件组件。在 Windows 系统上，一般可以从 java.com 下载免费的 Java 运行环境（JRE）。在 Macintosh 系统上，当一个应用需要 Java 运行环境时，会在启动时请求用户下载 Java。在类 Linux 系统上，Java 一般通过包管理器安装。 Windows 和 Mac 平台的开发者经常需要额外的工具，使用工具所需的免费 Java 开发包（JDK）必须从 Oracle下载并手动安装。 Java 会被编译为字节码，然后由 JVM 通过编译为原生代码进行解析工作。编译技术为动态编译（JIT）。最初这被视为降低性能的做法，但是随着 JVM 和 JIT 的发展，担忧逐渐减少。在某些情况下，例如当一个旧版本的处理器需要向后兼容时，JVM 甚至快于原生代码编译速度。 注意：也有其他供应商存在，然而大部分都有授权费。对于 linux 和其他平台，请查阅相关的操作系统文档。 版本包含主要的 Java 版本，代号和发行时间： JDK 1.0 (1996/01/23) JDK 1.1 (1997/02/19) J2SE 1.2 [Playground] (1998/12/08) J2SE 1.3 [Kestrel] (2000/05/08) J2SE 1.4 [Merlin] (2002/02/06) J2SE 5.0 [Tiger] (2004/09/30) Java SE 6 [Mustang] (2006/12/11) Java SE 7 [Dolphin] (2011/07/28) Java SE 8 [JSR 337] (2014/03/18) Java SE 9 [TBD ] (未发布) 最新的稳定版本： Java Standard Edition 8 Update 51 (1.8.0_51) - (2015/07/14) Java Standard Edition 7 Update 79 (1.7.0_79) - (2015/04/14) 更多的代号及发行日期请访问 J2SE Code Names。要查看 JDK 的版本发行日志请访问 Wikipedia 的 Java 版本历史文章。 Java SE 8 正在发行并且可下载。 公共更新的结束日期（以前称为结束生命）为： J2SE 1.4 - 2008/10 J2SE 5.0 - 2009/10 Java SE 6 - 2013/02 Java SE 7 - 2015/04 Java SE 8 - 2017/09 初始帮助你是 Java 初学者或者需要帮助使你的第一个 Java 程序运行？请参看 Oracle Java 教程开始部分。 询问问题前，请使用右上角的搜索栏查找是否已被询问（我们有很多相似的问题），并且阅读《如何提出一个好的问题》，学习怎样吸引 Jon Skeet 回答你的问题。 命名规范Java 程序需要坚持下列的命名规范以提高可读性和降低意外错误出现的可能性。通过遵守这些命名规范，可以使他人阅读你的代码和帮助你时更加轻松。 类型名（类，接口，枚举等等）应以大写字母开头，随后的每个单词首字母大写。例如：和 ```NullPointerException```。有时被称为 pascal case（帕斯卡命名法）。1234567891011121314151617**方法名**应使用 camelCased（驼峰式命名法），即它们应以小写字母开头，随后的每个单词首字母大写。例如：indexOf，printStackTrace，interrupt。**字段名**应使用和方法名一样的驼峰式命名法。**常量表达式命名**（```static final``` 不可变对象）应被写为 ALL_CAPS形式，使用下划线分割每个单词。例如：```YELLOW```，```DO_NOTHING_ON_CLOSE```。这同样应用于一个枚举类（```Enum```）的变量命名。然而，```static final``` 修饰可变对象时应使用驼峰式命名。## Hello World - 你的第一个程序**Hello World** 程序的代码为：``` javapublic class HelloWorld &#123;public static void main(String[] args) &#123;System.out.println(&quot;Hello, World!&quot;);&#125;&#125; 编译和调用 Hello world 程序： 12javac -d . HelloWorld.java java -cp . HelloWorld Java 源代码被编译为中间代码形式（针对 Java 虚拟机 的字节码指令），然后可以被 java 命令执行。 更多信息： Java 维基页面 JDK 维基页面 JRE 维基页面 Oracle 的 Java 下载页面 开发Java常用的IDE Eclipse IDE NetBeans IDE IntelliJ IDEA Spring Tool Suite（基于 Eclipse，包含用于 Spring 的插件） JDeveloper IDE Android Studio（基于 IntelliJ IDEA，主要用于 android 项目开发） BlueJ 初学者资源 The Java Tutorials - 从在 Windows/Linux/Mac 上的 scratch 开始，覆盖大部分标准库。 Generics Coding Bat (Java) - 学习部分基础之后，通过 Coding Bat 磨练和完善你的 Java 技术。 Java 编程规范 Stanford Java 视频课程 Udemy Java 免费课程 Edx 课程：Java 编程导论 日常帮助资源 Java SE 文档 Java 7 API 参考手册 Java 8 API 参考手册 进阶资源 Java 语言与虚拟机说明 其他可以在 JVM 上与 Java 混合使用的开发语言 免费 Java 编程图书与资源 《Linux 开发 Java 应用》（Carl Albing 与 Michael Schwarz 合著，PDF） 《如何像一名电脑科学家一样思考》 《Spring IO Guides》 《The Java EE7 Tutorial》（PDF） 《Java Thin-Client Programming》 《Oracle’s Java Tutorials》 《Thinking in Java》 《OSGi in Practice》（PDF） 《Category wise tutorials - J2EE》 《Java Example Codes and Tutorials - J2EE》 《Java Design Pattern Video Training》 常见问题人们在 Java 主题下经常询问的问题： 通用： Java 与 JavaScript 有什么不同 我如何将自己的 Java 程序转换为 .exe 文件 环境变量： 在环境变量中设置多种 jar 包 String，StringBuilder 与 toString： 在 Java 中如何比较字符串？ Java 中的 StringBuilder 与 StringBuffer 为什么当我在自己的 Java 项目中打印时得到 SomeType@2f92e0f4？ Java 中的字符串常量 equals 与 hashCode： equals() 和 == 有什么不同 在 Java 中重写 equals() 和 hashCode() 方法 Java Platform SE API： 使用 nextInt() 后跳过 nextLine() 在 Java 中比较日期 Java：在迭代集合的过程中做高效地删除操作 如何排序 Map&lt;Key, Value&gt; 中的值 什么时候使用 LinkedList&lt;&gt; 而不是 ArrayList&lt;&gt; 说明 Arrays.asList() HashMap 与 Hashtable 之间的区别 泛型： List&lt;Dog&gt; 是 List&lt;Animal&gt; 的子类吗？为什么 Java 的泛型不支持隐式多态? Java 泛型：PECS 是什么？ 原型是什么？为什么我们不应使用？ 如何创建一个泛型数组？ 类与对象： Java 是按引用传递的吗？ Java enum 对比 public static final字段的类有何优势？ public，protected，private 与 default 之间有什么区别 算法与规范： 为什么我不能正确地打印一个 double 类型？ 为什么整数做除法运算会返回 0？ Java 的 += 操作 调试： NullPointerException 是什么，我应该如何修复？ 堆栈追踪是什么？我应该如何使用才能调试自己的应用错误？ 我应该如何避免检查 null？ 为什么会出现 NoClassDefFoundError 错误？ Java 中的 NoSuchMethodError Thread 与多线程： java.lang.Thread.interrupt() 做了什么？ 无法通过打印语句查看循环中的变量改变 implements Runnable 对比 extends Thread 与操作系统交互： 为什么 Runtime.exec(String) 只在一些命令下产生作用？ (提交者们，请仅仅列出经常被询问的问题。) 聊天室 Stack Overflow 的 Java 聊天室 java-and-android-era 原文链接： stackoverflow翻译： ImportNew.com - honoka译文链接： http://www.importnew.com/16689.html","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://honoka.me/categories/编程技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://honoka.me/tags/Java/"}],"keywords":[{"name":"编程技术","slug":"编程技术","permalink":"http://honoka.me/categories/编程技术/"}]},{"title":"程序员应如何提高实效?读《程序员修炼之道》有感","slug":"程序员应如何提高实效？读《程序员修炼之道》有感","date":"2015-07-16T14:00:41.000Z","updated":"2018-04-16T15:01:12.000Z","comments":true,"path":"2015/07/16/程序员应如何提高实效？读《程序员修炼之道》有感/","link":"","permalink":"http://honoka.me/2015/07/16/程序员应如何提高实效？读《程序员修炼之道》有感/","excerpt":"《程序员修炼之道》浅谈","text":"《程序员修炼之道》浅谈 不得不说，《程序员修炼之道》的译名透着一股浓浓的山寨气息，曾经让我敬而远之。后来当我在工作效率上频频碰壁，又找不到突破的途径时，因为朋友的强烈推荐让我又拾起了这本书。 翻开书本刚刚阅读了序言，其中关于想要提高实效的程序员应培养何种特征一下子就击中大脑，原来如此，原来我就欠缺在这些地方啊，突然就有了一种不写不快的冲动。 书中提到了由于每个开发者的个体性，必然会营造出属于自己的个体环境，但是注重实效的程序员所拥有的特征却惊人的一致： 早期的采纳者/快速的改编者。 拥有学习一切的直觉，喜爱试验各种新技术，并联系自己的知识网络，然后运用在相关工作中。 好奇 喜欢提问，不错过每一个美妙的实现，不放过每一个偶然遇见的bug，每一个小点都可能会应用到以后的某个场景。 批判的思考者 喜欢挑战，讨厌照搬别人的说法和解决方案，不会放弃思考。 有现实感 设法理解你面临的每个问题的内在本质。对每一项任务有着良好的感知，事情有多困难？需要多长时间？了解困难才会有战胜困难的毅力。 多才多艺 尽力熟悉广泛的技术和环境，并且在努力工作的同时，使自己的技术池与时俱进，以备随时可能面对的新领域和新挑战。 或许这五点略显宽泛，但是在工作中随时注意，在某个情景下就会灵光一闪：“啊，这个时候我应该XXX做最有实效”，那么便会不断成长，在此与诸君共勉。","categories":[{"name":"编程技术, 读后感","slug":"编程技术-读后感","permalink":"http://honoka.me/categories/编程技术-读后感/"}],"tags":[{"name":"读后感","slug":"读后感","permalink":"http://honoka.me/tags/读后感/"}],"keywords":[{"name":"编程技术, 读后感","slug":"编程技术-读后感","permalink":"http://honoka.me/categories/编程技术-读后感/"}]},{"title":"高德地图开发小记の如何判断点是否在折线上","slug":"高德地图开发小计の如何判断点是否在折线上","date":"2015-04-16T15:08:24.000Z","updated":"2018-04-16T15:36:02.000Z","comments":true,"path":"2015/04/16/高德地图开发小计の如何判断点是否在折线上/","link":"","permalink":"http://honoka.me/2015/04/16/高德地图开发小计の如何判断点是否在折线上/","excerpt":"高德地图开发中的一个问题解决小记","text":"高德地图开发中的一个问题解决小记 背景最近使用高德地图 JavaScript API 开发地图应用，提炼了不少心得，故写点博文，做个系列总结一下，希望能帮助到 LBS 开发同胞们。 项目客户端使用高德地图 JavaScript API，主要业务为以区县为基础自由划分区域，并将划分好的区域存入数据库，以作后续操作。 开发之初便遇见一个问题，客户可以在城市区县范围内自由划分自己需要的区域，但是高德地图并未提供自定义区域的实现方法，所以只能借助 API 自造轮子。 经过讨论得出一个实现方法，初始加载城市区县区域后，自定义折线对象，然后在区域内通过鼠标点击画出折线，再将该折线对象和已有区域边界的路径值一起保存进数据库，便能够构成划分后的两个新区域了。 研究出实现方法后，遇见了一个难题，如何判断鼠标点击的点是否在折线上： 画起点和终点时必须在原有区域线上，否则无法形成新的封闭空间。故需要判断鼠标点击的点是否在原有折线上，在就让其成为起点或终点，不在则让其重新点击。 但是用户点击时无法保证完全点击在原有折线上，故需要允许一定的误差，在误差内则判断为点在折线上，误差外让其重新点击。 判断为在误差内后，鼠标点终究不在折线上，此时需要在原折线上生成一个新的点（离该鼠标点最近的点） 初期方案一开始希望通过判断折线上每两个相邻点与鼠标点三点共线则证明点在折线上，参阅《代码之美》后，发现了两种解决算法： 一种是判断斜率相等，但是由于以下问题被《代码之美》否决，并提出了更加优化的方法。 判断斜率相等存在多种特殊情况，如两点经度相等或者纬度相等时，代码实现过于繁琐。 斜率使用除法计算为浮点数，存在一定误差。 更优化的方法为三点可以组成一个三角形，当三角形面积接近于0时，则判断点在线上。具体细节可以参看《代码之美》第33章。在实际运用中，发现如果只存在三个点时，计算三角形面积毫无疑问是一个优秀的算法。 但是如前文提到的，鼠标点无法精确点击在折线上，故需要允许一定误差，也就是说三角形面积无法等于0，只能遍历折线每两个相邻点，计算鼠标点与两点组成的三角形面积，取出最小的面积，当其小于一个误差值时，点在折线上。 这样就可能会产生缺陷。一个折线对象存在着数以千计的相邻点，当鼠标点与折线上某两个相邻点组成的三角形面积最小时，却无法保证该点一定离这两个相邻点最近。 理想情况下是这样的。 三角形面积最小，并且鼠标点离该两点组成的线段最近。 而特殊情况下会是这样的. 三角形面积同样最小，但鼠标点其实离线段较远。 他山之石无奈只能另寻解决方法，然后在百度 LBS 开源库中发现几何运算类提供了判断线是否在折线上的方法 isPointOnPolyline()，大喜，赶紧研究一番，应用在项目中。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 判断点是否在矩形内 * @param &#123;Point&#125; point 点对象 * @param &#123;Bounds&#125; bounds 矩形边界对象 * @returns &#123;Boolean&#125; 点在矩形内返回true,否则返回false */function isPointInRect(point, bounds) &#123; var sw = bounds.getSouthWest(); //西南脚点 var ne = bounds.getNorthEast(); //东北脚点 return (point.lng &gt;= sw.lng &amp;&amp; point.lng &lt;= ne.lng &amp;&amp; point.lat &gt;= sw.lat &amp;&amp; point.lat &lt;= ne.lat);&#125;/** * 判断点是否在折线上 * @param &#123;Point&#125; point 点对象 * @param &#123;Polyline&#125; polyline 折线对象 * @returns &#123;Boolean&#125; 点在折线上返回true,否则返回false */function isPointOnPolyline(point, polyline) &#123; //首先判断点是否在线的外包矩形内，如果在，则进一步判断，否则返回false var lineBounds = polyline.getBounds(); if (!this.isPointInRect(point, lineBounds)) &#123; return false; &#125; //判断点是否在线段上，设点为Q，线段为P1P2 ， //判断点Q在该线段上的依据是：( Q - P1 ) × ( P2 - P1 ) = 0，且 Q 在以 P1，P2为对角顶点的矩形内 var pts = polyline.getPath(); for (var i = 0; i &lt; pts.length - 1; i++) &#123; var curPt = pts[i]; var nextPt = pts[i + 1]; // 首先判断point是否在curPt和nextPt之间，即：此判断该点是否在该线段的外包矩形内，先判断离point最近的两个相邻点，再进行斜率计算，有效避免干扰 if (point.lng &gt;= Math.min(curPt.lng, nextPt.lng) &amp;&amp; point.lng &lt;= Math.max(curPt.lng, nextPt.lng) &amp;&amp; point.lat &gt;= Math.min(curPt.lat, nextPt.lat) &amp;&amp; point.lat &lt;= Math.max(curPt.lat, nextPt.lat)) &#123; //判断点是否在直线上公式，此处使用减法计算两个斜率之差，有效地简化了特殊情况的判断 var precision = (curPt.lng - point.lng) * (nextPt.lat - point.lat) - (nextPt.lng - point.lng) * (curPt.lat - point.lat); if (precision &lt; 2e-10 &amp;&amp; precision &gt; -2e-10) &#123;//实质判断是否接近0 return true; &#125; &#125; &#125; return false;&#125; 测一测项目，哈哈，可行，长舒一口气。正准备好好放松下，OMG！又遇见缺陷了。 如下图北京西城区存在的一个情况： 此时折线上相邻两点的经度几乎相等。 或者北京丰台区存在的情况： 此时折线上相邻两点的纬度几乎相等。 由于方法优先判断鼠标点是否在折线某相邻两点的外包矩形内，但是上述两种情况下，相邻两点的外包矩形几乎为0，则鼠标点只有在精确点击到折线的情况下才会判断为true。这与实际开发中要求允许一定误差是相悖的，无奈只能另寻解决方法。 最终解决皇天不负有心人，在两次推翻实现算法后，终于又找到一种解决方法。遍历折线对象取出所有相邻点，计算鼠标点到每两个相邻点组成的线段的最短距离，然后排序最短距离，取出其中最小的距离，如果小于误差范围，则判断点在折线上。如果需要闭合区间，则在折线上生成一个离鼠标点最近的折线点（一般取垂足经纬度）。实现代码如下（代码已分享至 github）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170/** * 两点之间的距离 * @param x1 第一个点的经度 * @param y1 第一个点的纬度 * @param x2 第二个点的经度 * @param y2 第二个点的纬度 * @returns distance 两点之间的距离 */export function getPoToPoDis(x1, y1, x2, y2) &#123; return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))&#125;/** * 点到折线上相邻两点组成的线段的最短距离 * @param point 点坐标 * @param curPt 折线点坐标 * @param nextPt 与 curPt 相邻的折线点坐标 * @returns distance 距离 */export function getPoToLineDis(point, curPt, nextPt) &#123; const &#123; lng: xCur, lat: yCur &#125; = curPt // 折线点经纬度，将此点记作 P1 const &#123; lng: xNext, lat: yNext &#125; = nextPt // 相邻折线点经纬度，将此点记作 P2 const &#123; lng: xPoint, lat: yPoint &#125; = point // 外点经纬度，将此点记作 P const lengthCurToNext = getPoToPoDis(xCur, yCur, xNext, yNext); // P1 到 P2 的长度，记作 a 线段 const lengthCurToPo = getPoToPoDis(xCur, yCur, xPoint, yPoint); // P1 到 P 的长度，记作 b 线段 const lengthNextToPo = getPoToPoDis(xNext, yNext, xPoint, yPoint); // P2 到 P 的长度，记作 c 线段 let distance = 0 if (lengthNextToPo + lengthCurToPo === lengthCurToNext) &#123; // 当 b + c = a 时，P 在 P1 和 P2 组成的线段上 distance = 0 &#125; else if (lengthNextToPo * lengthNextToPo &gt;= lengthCurToNext * lengthCurToNext + lengthCurToPo * lengthCurToPo) &#123; // 当 c * c &gt;= a * a + b * b 时组成直角三角形或钝角三角形，投影在 P1 延长线上 distance = lengthCurToPo &#125; else if (lengthCurToPo * lengthCurToPo &gt;= lengthCurToNext * lengthCurToNext + lengthNextToPo * lengthNextToPo) &#123; // 当 b * b &gt; c * c + a * a 时组成直角三角形或钝角三角形，投影在 p2 延长线上 distance = lengthNextToPo &#125; else &#123; // 其他情况组成锐角三角形，则求三角形的高 const p = (lengthCurToPo + lengthNextToPo + lengthCurToNext) / 2 // 半周长 const s = Math.sqrt(p * (p - lengthCurToNext) * (p - lengthCurToPo) * (p - lengthNextToPo)) // 海伦公式求面积 distance = 2 * s / lengthCurToNext // 点到线的距离（利用三角形面积公式求高) &#125; return distance&#125;/** * 判断点是否在矩形内 * @param point 点对象 * @param bounds 矩形边界对象 * @returns 点在矩形内返回 true,否则返回 false */export function isPointInRect(point, bounds) &#123; const sw = bounds.getSouthWest() // 西南脚点 const ne = bounds.getNorthEast() // 东北脚点 return (point.lng &gt;= sw.lng &amp;&amp; point.lng &lt;= ne.lng &amp;&amp; point.lat &gt;= sw.lat &amp;&amp; point.lat &lt;= ne.lat)&#125;/** * 得到离鼠标点最近的折线点坐标 * @param point 鼠标点 * @param curPt，nextPt 折线上相邻两点 * @param precision 误差，默认 2e-4 * @returns &#123; polyLng, polyLat &#125; 折线点经纬度 */export function genPointOnPolyline(point, curPt, nextPt, precision = 2e-4) &#123; let pointLng, pointLat const precisionLng = curPt.lng - nextPt.lng const precisionLat = curPt.lat - nextPt.lat if (precisionLng &lt; precision &amp;&amp; precisionLng &gt; -precision) &#123; // 当折线上两点经度几乎相同时（存在一定误差） pointLng = curPt.lng pointLat = point.lat // 创建生成点对象 return &#123; pointLng, pointLat &#125; &#125; else if (precisionLat &lt; 2e-6 &amp;&amp; precisionLat &gt; -2e-6) &#123; // 当折线上两点纬度相同时（存在一定误差） pointLat = curPt.lat pointLng = point.lng return &#123; pointLng, pointLat &#125; &#125; // 其他情况，求得点到折线的垂足坐标 const k = (nextPt.lat - curPt.lat) / (nextPt.lng - curPt.lng) // 求得该点到线段的垂足坐标 // 设线段的两端点为 pt1 和 pt2，斜率为：k = (pt2.y - pt1.y) / (pt2.x - pt1.x); // 该直线方程为：y = k * (x - pt1.x) + pt1.y。其垂线的斜率为 - 1 / k， // 垂线方程为：y = (-1 / k) * (x - point.x) + point.y const pointLng2 = (k * k * curPt.lng + k * (point.lat - curPt.lat) + point.lng) / (k * k + 1) const pointLat2 = k * (pointLng2 - curPt.lng) + curPt.lat return &#123; pointLng2, pointLat2 &#125;&#125;/** * 判断点在一定误差范围内是否在折线上 * @param point 鼠标点 * @param polygon 区域多边形对象 * @param precision 误差范围, 默认 2e-4 * @returns 如果判断点不在折线上则返回false,否则返回true */export function isPointOnPloyline(point, polygon, precision = 2e-4) &#123; // 首先判断点是否在线的外包矩形内，如果在，则进一步判断，否则返回false if (!isPointInRect(point, polygon.getBounds())) &#123; return false &#125; const distances = [] // 点到折线每相邻两点的最短距离 const pts = polygon.getPath() // 折线路径点数组 pts.forEach((p, i) =&gt; &#123; distances.push(getPoToLineDis(point, pts[i], pts[i + 1])) distances.sort() &#125;) const minDistance = distances[0] if (minDistance &lt; precision &amp;&amp; minDistance &gt; -precision) &#123; // 当最短距离小于误差值时，判断鼠标点在折线上 return true &#125; return false&#125;/** * 如果点到折线最短距离在误差范围内，则得到离该点最近的折线点坐标，否则返回鼠标点坐标 * @param point 鼠标点 * @param polygon 区域多边形对象 * @param precision 误差，默认 2e-4 * @returns 如果判断点不在折线上则返回该点（point），如果判断点在折线上则返回计算出的折线最近点（ * 因为鼠标点选很难精确点在折线上，要允许一定误差，故需得到一个折线上的最近点） */export function genMinDisPoint(point, polygon, precision) &#123; if (!isPointInRect(point, polygon.getBounds())) &#123; return false &#125; let curPt, nextPt const distances = [] // 点到折线每相邻两点的最短距离 const points = [] // 折线相邻点 const pts = polygon.getPath() // 折线路径点数组 pts.forEach((p, i) =&gt; &#123; curPt = pts[i] nextPt = pts[i + 1] const distance = getPoToLineDis(point, curPt, nextPt) // 先将存储最短距离的数组排序，如果该两个相邻点与鼠标点计算出的最短距离与数组中最小距离相等，则存储该两点 distances.push(distance) distances.sort() if (distance === distances[0]) &#123; points.concat([curPt, nextPt]) &#125; &#125;) // 取得 points 最后两项，即最短距离最小时鼠标点两侧的折线点 curPt = points[points.length - 2] nextPt = points[points.length - 1] const minDistance = distances[0] if (minDistance &lt; precision &amp;&amp; minDistance &gt; -precision) &#123; // 当最短距离小于误差值时，判断鼠标点在折线上，通过鼠标点和两侧相邻点，得到折线上的最近点 return genPointOnPolyline(point, curPt, nextPt) &#125; return point&#125; 测试一番，终于解决了缺陷，能够正常判断点是否在折线上，并生成构建自定义区域及一个闭合区域所需要的最近折线点。 总结可以发现随着缺陷的不断解决，代码量却越来越多。毫无疑问，保持代码整洁，简化实现逻辑是一名开发人员应有的意识。不过在过度简化实现逻辑的过程中，我们是否会忽略许多用户实际使用时将会遭遇的错误呢。 回顾该功能跌宕的开发流程，就会发现： 如果折线不是一个闭合空间，而仅仅是较少点组成的几段线段时，三角形面积的算法遇见的缺陷没有出现的机会，将是最适合的算法。 如果折线点较多，但是其中不存在经度或纬度几乎相等的相邻点时，百度提供的算法又将是最适合的算法。 如果折线点较多，且情况复杂时，采用最后“较重”的算法，才能避免缺陷，成为一枚正常运转的齿轮。 所以“因地制宜”是一种非常重要的思想，不同的数据结构有不同的优劣势，同样不能因为怕某种框架太“轻”，覆盖面窄就避免使用，也不能因为框架太“重”就回避它。整日争辩哪种技术最好是没有意义的，我们需要做的是了解一种技术的最适使用场景，遇见该场景时使用它，享受技术开发者奉献给使用者的那份便捷。","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}],"tags":[{"name":"LBS","slug":"LBS","permalink":"http://honoka.me/tags/LBS/"}],"keywords":[{"name":"前端技术","slug":"前端技术","permalink":"http://honoka.me/categories/前端技术/"}]}]}